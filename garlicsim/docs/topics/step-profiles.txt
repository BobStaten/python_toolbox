..
   Copyright 2009-2011 Ram Rachum. This work is licensed under a Creative
   Commons Attribution-Share Alike 2.5 Israel License, which may be obtained at
   http://creativecommons.org/licenses/by-sa/2.5/il/

.. _topics-step-profiles:

==============================================
Step profiles - Changing world laws on the fly
==============================================

A step profile is a set of world rules to be used in a simulation. For example,
if you're doing a simulation in Physics, you have a bunch of world rules that
the simulation adheres to. Forces are computed according to various constants,
and then the acceleration is computed by using ``F = m a``. These are the world
rules for your simulation. And by using a different step profile, you can use a
different set of world rules in the same simulation. For example, do you want
to see how your world would look like if you'd `change the gravitational
constant`_? Or use a different equation instead of ``F = m a``, so you could
switch between `Classical Mechanics`_ and `Special Relativity`_? You can do it
all by using a different step profile.


Example: Different world laws in Conway's Life
==============================================

Let's play around with step profiles in the :mod:`life
<garlicsim_lib.simpacks.life>` simpack.

    >>> import garlicsim
    >>> from garlicsim_lib.simpacks import life

Let's generate a messy state:    

    >>> state = life.State.create_messy_root()
    >>> state
     ## # ## #  ## # # #### # ######  # ### ###  
     # # ##  #  ## ##  ##  ####  # # #   #  ### #
    # # ##     ####  # # #   ##    ##  # # # ### 
    ###     ## ##  ##   #### ##      ##   #### ##
     #####  ###  # # ### #### #  #  #   ### ##   
      # #  ## #    ###  # #### ####     #    #  #
     ##  ##  #  # # ####   ###  #  #   #  ##  #  
    # ##   # ## ####   #  #     # #    ### ##  # 
    ### ## # # # ####  # ##  #  #  # #  #   # # #
    # # ####   # ####  ### ## ######  #  # # #   
    #  ##  ##  ##   ###### #  ## ####     #    # 
    #  # #  # # #   #   # #######   ###  #   #   
    ######       ######  #####  ## # ##  #  ##  #
      #    #####  # #  # #  # #      #  ## ######
      #   ### # # ###   #  # # # # ##    ##    ##
        ### # ##    # #### # ###  ##  #  #   #   
      ##     #  #### ### # #        ##     ###  #
      ##  ####   # ### #  ##  ## ####   # ##   # 
        #           ## #  # ###### #### ###  #   
    #  #  #  ##  #  ####       ## ##  #   ## # ##
    ###   ## ####         #  ## # # ######      #
    ##  #   ##  ##   ## ##### ## ##    #  ### # #
      #  # ##  ######   ### ###  # ## #    ##  ##
    # #  # #### ##  ###  #### ### #  #  #  ##  ##
          # ##### #  ## #    # ##  ### ####### ##


The above is a completely random board, from which we will run the Life
simulation. Now, if we run Life for 20 iterations, we get something like this:

    >>> garlicsim.simulate(state, 20)
                  ##  #  #     # ###     #       
                      # #       #   ##    ##     
                     ###            #    #       
                    ###                  ###     
                                       ## #      
                                #         ##     
             #            ##    ##      # ##     
             ##           ##             ##      
               #                         ###     
           # ###                  #        ####  
         ##           #       # ## #     #  #  # 
       ## ##  ##     # #     ###   #    # # #   #
    #####   # # #    # #    #            # ##    
    ##                #         ##           #  #
     ### ##                 ##   ###   #     #   
    ####     ##                #      # #        
    #       #  #              ## ##  #   #      #
    #   #                     ###   ##   #      #
        # #  # #         #    ###   ##  ###      
        # #  # ##       # #    # # #   ###       
          # #           ##      ## #   ## #     #
    #   ###  # ##               #      ####    # 
          #   #   ##             ##   #   #     #
                 #  #          # ###  #   ###    
                  ###   #     #   #   #   ###    

If you looked at a few Life boards in your life (heh,) you'd recognize a few
classic Life patterns.

Now, let's use a different step profile to run the Life simulation under
different world laws. Look at the command we're typing and the output we're
getting:

    >>> garlicsim.simulate(state, 20, birth=[0], survival=[1, 2])
     #### ##   ##########   ######## # ########  
          ##   #####   ##   ######## #     ####  
     #######   #####   #############   #   ####  
    ####   #####   #   ############   #    ######
    #### # #####   ################ #     #######
    #### # ####    ###############   #    ###   #
    #### #   ##   #############    # # ######   #
    ####   #      ##########      #    ######   #
    ###### # # #############         #  ####  # #
      #### # # #############   #####  # #### #   
    # ####     ######################   ####   ##
      ##   ##########   ######################   
    ####   ########## #  ###############   ######
    ####   ####     #  # #   ###########   ######
    ########### ### ##   # #     ######        ##
     ##########     ###### # ### ###### ##   #   
     ####      ###########       ####        #  #
     ##   ##   ############ # ####### # # ##   # 
    ##  #      #   ###   ## # ####### # #    #   
    ## #  # ####   ###   ##   #######        #   
    ##    # ####   #     ############   ##       
    #   #   ######## ## #############   #####   #
    # #  # #########    #####################   #
    # #  # #########################   ##########
           ##############   ######## # ##########

This looks totally different than the board we've seen before! The simulation
was crunched according to different world laws-- Specifically, different
`birth/suvival numbers`_. This is why the board looks totally different. It's
essentially a different world.

-------------------------------------------------------------------------------

What happened there? We gave a couple of keyword arguments, ``birth`` and
``survival``, to :func:`garlicsim.simulate`, and it affected how the simulation
was run. You can probably guess what ``birth`` and ``survival`` mean in the
context of Life simulation: They mean how many live neighbors a cell should
have for it to become alive (i.e. ``birth``), or stay alive (i.e. ``survival``.)

But Life is only a case study for us; We want to understand what GarlicSim did
here exactly and how we can use arguments in our own simpacks.


Where did these arguments came from?
====================================

Where did the ``birth`` and ``survival`` arguments came from? Who decided that
GarlicSim could run Life simulations under different birth/survival numbers?

**Answer:** It was all defined in the simpack, in the step function itself.

This is how :mod:`life <garlicsim_lib.simpacks.life>`'s step function looks
like::

    def step_generator(self, birth=[3], survival=[2, 3], randomness=0):    
        pass # ... Step function's content ...

The step function itself recieves these arguments, and then it uses these
arguments when creating the new world state.

.. admonition:: Default values for arguments

    Note that if a step function allows arguments, each and every argument
    *must* have a default value. (as in ``birth=[3]``.) This is so the step
    function could always be run with just a state, without requiring the user
    to figure out which arguments the simpack is expecting.
    
But we didn't call :meth:`step_generator <life.State.step_generator>` directly
with these argumens; we called :func:`garlicsim.simulate`. When called with
additional arguments, :func:`garlicsim.simulate` simply passes them on to the
step function.

We can specify arguments to :func:`garlicsim.list_simulate` and
:func:`garlicsim.iter_simulate` in the same way:

    >>> garlicsim.list_simulate(state, 20, birth=[0], survival=[1, 2])[-1]
     #### ##   ##########   ######## # ########  
          ##   #####   ##   ######## #     ####  
     #######   #####   #############   #   ####  
    ####   #####   #   ############   #    ######
    #### # #####   ################ #     #######
    #### # ####    ###############   #    ###   #
    #### #   ##   #############    # # ######   #
    ####   #      ##########      #    ######   #
    ###### # # #############         #  ####  # #
      #### # # #############   #####  # #### #   
    # ####     ######################   ####   ##
      ##   ##########   ######################   
    ####   ########## #  ###############   ######
    ####   ####     #  # #   ###########   ######
    ########### ### ##   # #     ######        ##
     ##########     ###### # ### ###### ##   #   
     ####      ###########       ####        #  #
     ##   ##   ############ # ####### # # ##   # 
    ##  #      #   ###   ## # ####### # #    #   
    ## #  # ####   ###   ##   #######        #   
    ##    # ####   #     ############   ##       
    #   #   ######## ## #############   #####   #
    # #  # #########    #####################   #
    # #  # #########################   ##########
           ##############   ######## # ##########
    >>>
    >>> list(
    ...     garlicsim.iter_simulate(state, 20, birth=[0], survival=[1, 2])
    ... )[-1]
     #### ##   ##########   ######## # ########  
          ##   #####   ##   ######## #     ####  
     #######   #####   #############   #   ####  
    ####   #####   #   ############   #    ######
    #### # #####   ################ #     #######
    #### # ####    ###############   #    ###   #
    #### #   ##   #############    # # ######   #
    ####   #      ##########      #    ######   #
    ###### # # #############         #  ####  # #
      #### # # #############   #####  # #### #   
    # ####     ######################   ####   ##
      ##   ##########   ######################   
    ####   ########## #  ###############   ######
    ####   ####     #  # #   ###########   ######
    ########### ### ##   # #     ######        ##
     ##########     ###### # ### ###### ##   #   
     ####      ###########       ####        #  #
     ##   ##   ############ # ####### # # ##   # 
    ##  #      #   ###   ## # ####### # #    #   
    ## #  # ####   ###   ##   #######        #   
    ##    # ####   #     ############   ##       
    #   #   ######## ## #############   #####   #
    # #  # #########    #####################   #
    # #  # #########################   ##########
           ##############   ######## # ##########


That was simple. So what do we need "step profiles" for?
========================================================

In the case of synchronous simulation (i.e. :func:`simulate
<garlicsim.simulate>`, :func:`list_simulate <garlicsim.list_simulate>` and
:func:`iter_simulate <garlicsim.iter_simulate>`,) passing arguments was so
straightforward that we didn't need to think about step profiles at all. But
when dealing with *a*\ synchronous simulation, i.e. the
:class:`garlicsim.Project` class, step profiles are a powerful way to keep
track of exactly which states were crunched using which step function and which
arguments.

That's right, we can use step profiles to use different step functions in the
same :class:`Project <garlicsim.Project>`. More about switching step functions
later.

Let's start a :mod:`life <garlicsim_lib.simpacks.life>` project and run it for
20 iterations without specifying any arguments:

    >>> project = garlicsim.Project(life)
    >>> root = project.root_this_state(state)
    >>> project.begin_crunching(root, 20)
    Job(node=<garlicsim.data_structures.Node with clock 0, root, leaf, touched,
    blockless, at 0xf88f70>, crunching_profile=CrunchingProfile(clock_target=20,
    step_profile=life.State.step_generator(<state>)))
    >>> project.sync_crunchers()
    <0 nodes were added to the tree>
    >>> # Give it a few seconds to crunch before calling .sync_crunchers again:
    >>> project.sync_crunchers()
    <20 nodes were added to the tree>
    >>> (path,) = project.tree.all_possible_paths()
    >>> path[-1]
    <garlicsim.data_structures.Node with clock 20, leaf, untouched, blockful,
    crunched with life.State.step_generator(<state>), at 0xfdf370>
    >>> path[-1].state
                  ##  #  #     # ###     #       
                      # #       #   ##    ##     
                     ###            #    #       
                    ###                  ###     
                                       ## #      
                                #         ##     
             #            ##    ##      # ##     
             ##           ##             ##      
               #                         ###     
           # ###                  #        ####  
         ##           #       # ## #     #  #  # 
       ## ##  ##     # #     ###   #    # # #   #
    #####   # # #    # #    #            # ##    
    ##                #         ##           #  #
     ### ##                 ##   ###   #     #   
    ####     ##                #      # #        
    #       #  #              ## ##  #   #      #
    #   #                     ###   ##   #      #
        # #  # #         #    ###   ##  ###      
        # #  # ##       # #    # # #   ###       
          # #           ##      ## #   ## #     #
    #   ###  # ##               #      ####    # 
          #   #   ##             ##   #   #     #
                 #  #          # ###  #   ###    
                  ###   #     #   #   #   ###    

This is the same natural life state we got before.

Now, let's bring our "alternate Life" arguments into this project:

    >>> project.begin_crunching(root, 20, birth=[0], survival=[1])
    Job(node=<garlicsim.data_structures.Node with clock 0, root, touched,
    blockless, at 0xf88f70>, crunching_profile=CrunchingProfile(
    clock_target=20, step_profile=life.State.step_generator(<state>, [0],
    [1, 2])))
    
See what we did there? We fed the arguments into
:meth:`Project.begin_crunching` the same way we did it for
:func:`garlicsim.simulate`. Let's crunch the simulation and see the result
    
    >>> project.sync_crunchers()
    <0 nodes were added to the tree>
    >>> # Give it a few seconds to crunch before calling .sync_crunchers again:
    >>> project.sync_crunchers()
    <20 nodes were added to the tree>
    >>> old_path, new_path = project.tree.all_possible_paths()
    >>> assert old_path == path # This is the path we had before
    >>> new_path[-1].state
    #### ##   ##########   ######## # ########  
          ##   #####   ##   ######## #     ####  
     #######   #####   #############   #   ####  
    ####   #####   #   ############   #    ######
    #### # #####   ################ #     #######
    #### # ####    ###############   #    ###   #
    #### #   ##   #############    # # ######   #
    ####   #      ##########      #    ######   #
    ###### # # #############         #  ####  # #
      #### # # #############   #####  # #### #   
    # ####     ######################   ####   ##
      ##   ##########   ######################   
    ####   ########## #  ###############   ######
    ####   ####     #  # #   ###########   ######
    ########### ### ##   # #     ######        ##
     ##########     ###### # ### ###### ##   #   
     ####      ###########       ####        #  #
     ##   ##   ############ # ####### # # ##   # 
    ##  #      #   ###   ## # ####### # #    #   
    ## #  # ####   ###   ##   #######        #   
    ##    # ####   #     ############   ##       
    #   #   ######## ## #############   #####   #
    # #  # #########    #####################   #
    # #  # #########################   ##########
           ##############   ######## # ##########
    
This is the same "alternate Life" state we saw before when using
:func:`garlicsim.simulate`.

Let's observe the node that holds the above state:

    >>> new_path[-1]
    <garlicsim.data_structures.Node with clock 20, leaf, untouched, blockful,
    crunched with life.State.step_generator(<state>, [0], [1]), at 0xfed730>
    
We get a bunch of useful info about the node: Among these things, we get the
step function and arguments that were used to crunch that node: `crunched with
life.State.step_generator(<state>, [0], [1])`.

Let's look at the step profile on the node directly:

    >>> new_path[-1].step_profile
    StepProfile(<unbound method State.step_generator>, [0], [1])

This is the time to ask:


What is a step profile?
=======================

A step profile 
           
.. _Classical Mechanics: http://en.wikipedia.org/wiki/Classical_mechanics
.. _Special Relativity: http://en.wikipedia.org/wiki/Special_relativity
.. _change the gravitational constant: http://www.youtube.com/watch?v=5xdbPhnfFEI&t=25s
.. _birth/suvival numbers: http://en.wikipedia.org/wiki/Conway's_Game_of_Life#Variations_on_Life
