..
   Copyright 2009-2011 Ram Rachum. This work is licensed under a Creative
   Commons Attribution-Share Alike 2.5 Israel License, which may be obtained at
   http://creativecommons.org/licenses/by-sa/2.5/il/

.. _topics-step-functions:

=============================================
The step function -- The heart of the simpack
=============================================

The step function is the most important part of a simpack. The step function
contains the world laws and tells GarlicSim how to calculate the next world
state in a simulation.

Writing a simple step function is easy and we'll show how to do it below; After
you've mastered that, we'll show you more advanced ways to define and use step
functions. We'll also show you the different kinds of step functions that
GarlicSim allows.

Different kinds of step functions
=================================

Below we will show the different kinds of step functions. Keep in mind that
your step function's type will be determined automatically from its name; For
example, a step function called ``step`` (or ``my_step`` or ``step_alternate``)
will be automatically identified as a simple step function; As another example,
a step function called ``history_step_generator`` (or
``faster_history_step_generator`` or ``my_awesome_history_step_generator``)
will be automatically identified as a history step generator.

If you wish to give a different name to your step function and specify its type
manually, you can do that by decorating the step function with the step type.


The simple step function
------------------------

The simple step function is also known as
:class:`garlicsim.misc.simpack_grokker.step_types.SimpleStep`.

Here's an example of a ``State`` class that defines a simple step function
which is only two lines long::

    class State(garlicsim.data_structures.State):
    
        def __init__(self, height):
            self.height = height
            
        def step(self):
            return State(self.height + 1)
        
In this step function we created a new state object, set one of its attributes,
and returned it. This is enough for GarlicSim to use this simpack to generate
states.

Do notice one thing we *didn't* do: We didn't set clock readings to our states.
When you simulate with GarlicSim, every state always gets a ``.clock``
attribute which says its clock reading. The step function usually assigns this
``.clock`` attribute, but when it doesn't, (such as in the example above,)
GarlicSim automatically gives each state a clock reading. Newly-created states
get a clock of 0 by default, and on every step the new state's clock reading
will be higher by 1 than that of the original state.


The inplace step function
-------------------------

The inplace step function is also known as
:class:`garlicsim.misc.simpack_grokker.step_types.InplaceStep`.

If you've written a simpack or two, you may have noticed that you often keep
many attributes on your world states. It can be a drag to recreate all of these
attributes in the step function. If you use an inplace step function, you don't
have to. Example::

    class State(garlicsim.data_structures.State):
    
        def __init__(self, height, weight, spin):
            self.height = height
            self.weight = weight
            self.spin = spin
                        
        def inplace_step(self):
            self.height += 1
            
The inplace step function changes the state in place instead of returning a new
state. An inplace step function doesn't return anything. (i.e., it returns
:data:`None`.) The modified state will still have all of the old attributes it
had. (In this example ``weight`` and ``spin``.)

But wait, you say. How can we modify a state in place? GarlicSim needs to keep
all the states in a time tree as constants, if states will be modified in
place, it will ruin the whole thing!

Well, GarlicSim is smart, and when it uses an inplace step function, it
duplicates the state before feeding it to the step function on every iteration,
so that the original state and all produced states that go to the tree are left
unaltered.

GarlicSim will also advance the new state's clock by one if the inplace step
function didn't advance it itself.

One more advatnage that the inplace step has is that if you use
:func:`garlicsim.simulate` with it, the step will actually be done in place for
better performance, without duplicating on every iteration. For example, if you
give :func:`garlicsim.simulate` an initial state and tell it to do 100
iterations, it will first deepcopy your initial state, then perform 100
iterations of the inplace step function *in place*, and then return the
resulting state. This is done only in :func:`garlicsim.simulate`, and not in
:class:`garlicsim.Project`, because :func:`garlicsim.simulate` is the only
function that doesn't reveal the interim states to the user, so we can afford
not to keep them as constants.


The step generator
------------------

The step generator is also known as
:class:`garlicsim.misc.simpack_grokker.step_types.StepGenerator`.

You can write your step as a generator. Example::

    boobz
    
asdasda


The inplace step generator
--------------------------


The history step function
-------------------------


The history step generator
--------------------------



Step functions can take arguments
=================================

