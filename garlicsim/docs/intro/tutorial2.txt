.. _intro-tutorial2:

===========================================
Tutorial part 2: Writing your first simpack
===========================================

In part 1 of the tutorial, we were playing around with someone else's simpack.
In part 2, we are going to make our own.

Motivation for our simpack
==========================

A few years ago, I was talking with a friend of mine about gambling. He said, "I
thought of a really sure-fire way to win money at a coinflip game. (Where it's
50/50 chance between doubling your money and losing it.) You bet $100. If you
win, you won $100 and you're done. If you lose, you bet $200. If you win that,
you've still got a net win of $100, and you're done. If you lose, you bet $400.
If you win *that*, you still have a net win of $100, etc."

"I guess you have a small chance of losing all your money, that's the drawback."

"Yeah, but you're almost sure to win the $100. So let's say you come to the
casino with $5,000, and you want to make $1,000. You use my method 10 times in a
row, and you almost certainly win $1,000!"

"Well, I don't know..."

We're going to make a simpack that will test whether my friend's method for
beating the casino is any good.

Starting a simpack using the :command:`start_simpack.py` script
===============================================================

A simpack is a Python package, and to create it you need to create a folder with
all the ``__init__.py`` files and everything. To save you that time, garlicsim
comes with a script called :command:`start_simpack.py`, which does all this for
you.

.. admonition:: The ``Scripts`` folder:

    When you installed garlicsim, the :command:`start_simpack.py` script got
    installed in your ``Scripts`` directory inside your Python distribution.
    Normally, the ``Scripts`` directory will be placed on your system's
    :envvar:`PATH` variable, and this will allow you to use
    :command:`start_simpack.py` directly from anywhere on your filesystem. If
    you try to run :command:`start_simpack.py` and get an error like "file not
    found", ensure that your ``Scripts`` directory is added to your system's
    :envvar:`PATH`.

Where do you want to put your simpack? Open up your shell and go to that folder.

::

    C:\>start_simpack.py coin_flip
    coin_flip simpack created successfully! Explore the coin_flip
    folder and start filling in the contents of your new simpack.

Alright! In the :file:`coin_clip` directory we will find the new files. This is its structure::

    coin_flip/
        __init__.py
        settings.py
        state.py
        wx/
            ...            
            (The wx folder isn't important now)
        

You should browse this folder yourself, and go over the files. These are the abridged contents of the most important file, :file:`state.py`, which you should read::

    import garlicsim.data_structures
    
    
    class State(garlicsim.data_structures.State):
        # This is your State subclass. Your state objects should contain all the
        # information there is about a moment of time in your simulation.
        
        def __init__(self):
            pass
        
        
        def step(self):
            # This function is the heart of your simpack. What it does is take an
            # existing world state, and output the next world state.
            #
            # This is where all the crunching gets done. This function defines the
            # laws of your simulation world.
            # 
            # The step function is one of the very few things that your simpack
            # **must** define. Almost all of the other definitions are optional.
            pass
        
            
        @staticmethod
        def create_root():
            # In this function you create a root state. This usually becomes the
            # first state in your simulation. You can make this function do
            # something simple: For example, if you're simulating Life, you can make
            # this function create an empty board.
            #
            # This function may take arguments, if you wish, to be used in making
            # the state. For example, in a Life simulation you may want to specify
            # the width and height of the board using arguments to this function.
            #
            # This function returns the newly-created state.
            pass
    
        
        @staticmethod
        def create_messy_root():
            # In this function you create a messy root state. This usually becomes the
            # first state in your simulation. 
            #
            # Why messy? Because sometimes you want to have fun in your simulations.
            # You want to create a world where there's a lot of mess, with many
            # objects interacting with each other. This is a good way to test-drive
            # your simulation.
            #
            # This function may take arguments, if you wish, to be used in making
            # the state. For example, in a Life simulation you may want to specify
            # the width and height of the board using arguments to this function.
            #
            # This function returns the newly-created state.
            pass
                                     
    
So now we can start filling in our simpack! But before that, we need to think
about the laws of our simulation and how we're going to represent them in the
:class:`State <garlicsim.data_structures.State>`.

Let's think about our simulation: We go into the casino, with a given amount of
money, say $5,000. Every turn we make a bet on a certain amount of dollars.
(That we must have at hand-- No loans at this casino.) We double our money or
lose it, with a 50/50 chance.

At first we bet $100. If we lose, we bet $200. If we lose again, we bet $400,
etc. If we win one of those before going bankrupt, we made a net profit of $100,
and then we start the cycle and bet $100 again.

Our goal is to make $1,000, i.e. have $6,000 in our account. If we reach that,
we win. If we lose all our money, we lose.

Here is an attempt to write this simpack. (You can fill this in to your files in
the :file:`coin_flip` folder.)

::

    import random
    import garlicsim.data_structures
        
    class State(garlicsim.data_structures.State):
        
        def __init__(self, balance, last_bet_result=0):
            
            garlicsim.data_structures.State.__init__(self)
            
            self.balance = balance
            '''The current balance of our account, i.e. how much money we have.'''
            
            self.last_bet_result = 0
            '''How much we won/lost in the last bet. `-100` means we lost $100.'''
        
        def step(self):
            if self.balance >= 6000:
                self.end_result = 6000
                return
            
            if self.last_bet_result in (0, 100):
                # Meaning either (1) we just started the simulation or (2) we
                # just won $100.                
                amount_to_bet = 100 # We're starting a new cycle
                
            else: 
                assert self.last_bet_result in (-100, -200, -400, -800,
                                                -1600, -3200, -6400)
                # If the flow reached here it means we just lost. So we
                # should bet double the amount:
                amount_to_bet = - 2 * state.last_bet_result
            
            # Now we know what the amount we should bet, let's do it!
            bet_result = random.choice([amount_to_bet, - amount_to_bet])
            
            new_balance = state.balance + bet_result
            
            new_state = State(new_balance, bet_result)
            
            return new_state
        
            
        @staticmethod
        def create_root():
            return State(balance=5000)

Frr::

    def f():
        return 'boobs'
    
Meow