..
   Copyright 2009-2012 Ram Rachum. This work is licensed under a Creative
   Commons Attribution-ShareAlike 3.0 Unported License, with attribution to
   "Ram Rachum at ram.rachum.com" including link. The license may be obtained
   at http://creativecommons.org/licenses/by-sa/3.0/

.. _topics-index:

`caching.cache`: A caching decorator that understands arguments
===============================================================

The idea of a caching decorator is very cool. You decorate your function with a
caching decorator:

   >>> from python_toolbox import caching
   >>> @caching.cache
   ... def f(x):
   ...     print('Calculating...')
   ...     return x ** x # Some long expensive computation
   >>> f(4)
   Calculating...
   256
   >>> f(5)
   Calculating...
   3125
   >>> f(5)
   3125
   >>> f(5)
   3125<
   
As you can see, after the first time we calculate ``f(5)`` the result gets
saved to a cache and every time we'll call ``f(5)`` Python will return the
result from the cache instead of calculating it again. This prevents making
redundant performance-expensive calculations.

Now, depending on the function, there can be many different ways to make the same call. Example, if you have a function defined like this:

    def g(a, b=2, **kwargs):
        return whatever

Then ``g(1)``, ``g(1, 2)``, ``g(b=2, a=1)`` and even ``g(1, 2, **{})`` are all equivalent. They give the exact same arguments, just in different ways. Most caching decorators out there don't understand that. If you call ``g(1)`` and then ``g(1, 2)``, they will calculate the function again, because they don't understand that it's exactly the same call and they could use the cached result.

Enter `caching.cache`:

   >>> @caching.cache()
   ... def g(a, b=2, **kwargs):
   ...     print('Calculating')
   ...     return (a, b, kwargs)
   ... 
   >>> g(1)
   Calculating
   (1, 2, {})
   >>> g(1, 2) # Look ma, no calculating:
   (1, 2, {})
   >>> g(b=2, a=1) # No calculating again:
   (1, 2, {})
   >>> g(1, 2, **{}) # No calculating here either:
   (1, 2, {})
   >>> g('something_else') # Now calculating for different arguments:
   Calculating
   ('something_else', 2, {})

That's the main cool thing about `caching.cache`


; It has other interesting features that I will not go in depth into:
<ul><li>It has a `max_size` argument which limits the size of the cache dict; old values get thrown away according to an <a href="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">LRU algorithm</a> implemented using (my bundled version of) Python&#8217;s <a href="http://docs.python.org/dev/library/collections.html#collections.OrderedDict">`OrderedDict`</a>, specifically the new <a href="http://docs.python.org/dev/library/collections.html#collections.OrderedDict.move_to_end">`OrderedDict.move_to_end`</a> method.</li>
<li>It stores arguments with <a href="https://github.com/cool-RR/GarlicSim/tree/master/garlicsim/garlicsim/general_misc/sleek_refs">sleekrefs</a>. Sleekrefs are a more robust variation of <a href="http://docs.python.org/library/weakref.html">weakrefs</a>. This prevents memory leaks when using potentially-heavy arguments. More about sleekrefs in a future blog post.</li>
<li>
It preserves the original function&#8217;s signature using <a href="http://www.artima.com/weblogs/index.jsp?blogger=micheles">Michele Simionato</a>&#8217;s excellent <a href="http://pypi.python.org/pypi/decorator">decorator module</a>.
</li>
</ul><h2>Source and tests for `caching.cache`</h2>
<a href="https://github.com/cool-RR/GarlicSim/blob/master/garlicsim/garlicsim/general_misc/caching/cache.py">Source for `caching.cache`, well-documented</a>. Here are <a href="https://github.com/cool-RR/GarlicSim/blob/master/garlicsim/test_garlicsim/test_general_misc/test_caching/test_cache.py">the tests</a>.
There is also a <a href="https://github.com/cool-RR/GarlicSim-for-Python-3.x/blob/master/garlicsim_py3/garlicsim/general_misc/caching/cache.py">Python 3 version of `caching.cache`</a>, and <a href="https://github.com/cool-RR/GarlicSim-for-Python-3.x/blob/master/garlicsim_py3/test_garlicsim/test_general_misc/test_caching/test_cache.py">here are its tests</a>. It&#8217;s available with the <a href="http://pypi.python.org/pypi/garlicsim_py3">Python 3 fork of GarlicSim</a>. Note that I haven&#8217;t tested it on Python 3&#8217;s <a href="http://www.python.org/dev/peps/pep-3102/">new kinds of function signatures</a>; I&#8217;ll be happy to get patches with tests and/or implementation of support for those.
<h2>Please give feedback!</h2>
I&#8217;ll be happy to get any opinions, critiques and code reviews on `caching.cache`!